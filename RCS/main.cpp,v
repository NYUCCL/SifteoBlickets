head	1.130;
access;
symbols;
locks
	j:1.130; strict;
comment	@// @;
expand	@o@;


1.130
date	2013.03.17.05.17.52;	author j;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.17.05.17.32;	author j;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.17.05.17.25;	author j;	state Exp;
branches;
next	1.127;

1.127
date	2013.03.17.05.16.56;	author j;	state Exp;
branches;
next	1.126;

1.126
date	2013.03.17.05.15.38;	author j;	state Exp;
branches;
next	1.125;

1.125
date	2013.03.17.05.14.57;	author j;	state Exp;
branches;
next	1.124;

1.124
date	2013.03.17.05.14.22;	author j;	state Exp;
branches;
next	1.123;

1.123
date	2013.03.17.05.14.03;	author j;	state Exp;
branches;
next	1.122;

1.122
date	2013.03.17.05.13.29;	author j;	state Exp;
branches;
next	1.121;

1.121
date	2013.03.17.05.11.54;	author j;	state Exp;
branches;
next	1.120;

1.120
date	2013.03.17.05.11.12;	author j;	state Exp;
branches;
next	1.119;

1.119
date	2013.03.17.05.11.02;	author j;	state Exp;
branches;
next	1.118;

1.118
date	2013.03.17.05.10.43;	author j;	state Exp;
branches;
next	1.117;

1.117
date	2013.03.17.05.09.58;	author j;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.17.05.09.49;	author j;	state Exp;
branches;
next	1.115;

1.115
date	2013.03.17.05.09.42;	author j;	state Exp;
branches;
next	1.114;

1.114
date	2013.03.17.05.01.52;	author j;	state Exp;
branches;
next	1.113;

1.113
date	2013.03.17.05.00.00;	author j;	state Exp;
branches;
next	1.112;

1.112
date	2013.03.17.04.59.37;	author j;	state Exp;
branches;
next	1.111;

1.111
date	2013.03.17.04.59.20;	author j;	state Exp;
branches;
next	1.110;

1.110
date	2013.03.17.04.57.05;	author j;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.17.04.56.57;	author j;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.17.04.55.57;	author j;	state Exp;
branches;
next	1.107;

1.107
date	2013.03.17.04.55.54;	author j;	state Exp;
branches;
next	1.106;

1.106
date	2013.03.17.04.54.51;	author j;	state Exp;
branches;
next	1.105;

1.105
date	2013.03.17.04.53.54;	author j;	state Exp;
branches;
next	1.104;

1.104
date	2013.03.17.04.53.23;	author j;	state Exp;
branches;
next	1.103;

1.103
date	2013.03.17.04.51.56;	author j;	state Exp;
branches;
next	1.102;

1.102
date	2013.03.17.04.51.51;	author j;	state Exp;
branches;
next	1.101;

1.101
date	2013.03.17.04.51.34;	author j;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.17.04.51.22;	author j;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.17.04.50.54;	author j;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.17.04.50.37;	author j;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.17.04.50.04;	author j;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.17.04.49.55;	author j;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.17.04.49.30;	author j;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.17.04.48.36;	author j;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.17.04.45.27;	author j;	state Exp;
branches;
next	1.92;

1.92
date	2013.03.17.04.44.10;	author j;	state Exp;
branches;
next	1.91;

1.91
date	2013.03.17.04.44.07;	author j;	state Exp;
branches;
next	1.90;

1.90
date	2013.03.17.04.43.53;	author j;	state Exp;
branches;
next	1.89;

1.89
date	2013.03.17.04.43.16;	author j;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.17.04.42.41;	author j;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.17.04.42.39;	author j;	state Exp;
branches;
next	1.86;

1.86
date	2013.03.17.04.42.07;	author j;	state Exp;
branches;
next	1.85;

1.85
date	2013.03.17.04.41.47;	author j;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.17.04.39.58;	author j;	state Exp;
branches;
next	1.83;

1.83
date	2013.03.17.04.39.33;	author j;	state Exp;
branches;
next	1.82;

1.82
date	2013.03.17.04.38.44;	author j;	state Exp;
branches;
next	1.81;

1.81
date	2013.03.17.04.38.08;	author j;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.17.04.32.22;	author j;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.17.04.31.48;	author j;	state Exp;
branches;
next	1.78;

1.78
date	2013.03.17.04.30.29;	author j;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.17.04.29.10;	author j;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.17.04.28.30;	author j;	state Exp;
branches;
next	1.75;

1.75
date	2013.03.17.04.27.32;	author j;	state Exp;
branches;
next	1.74;

1.74
date	2013.03.17.04.26.43;	author j;	state Exp;
branches;
next	1.73;

1.73
date	2013.03.17.04.26.34;	author j;	state Exp;
branches;
next	1.72;

1.72
date	2013.03.17.04.25.02;	author j;	state Exp;
branches;
next	1.71;

1.71
date	2013.03.17.04.21.57;	author j;	state Exp;
branches;
next	1.70;

1.70
date	2013.03.17.04.20.27;	author j;	state Exp;
branches;
next	1.69;

1.69
date	2013.03.17.04.20.04;	author j;	state Exp;
branches;
next	1.68;

1.68
date	2013.03.17.04.17.27;	author j;	state Exp;
branches;
next	1.67;

1.67
date	2013.03.17.04.17.20;	author j;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.17.04.17.07;	author j;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.17.04.16.49;	author j;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.17.04.16.30;	author j;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.17.04.16.22;	author j;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.17.04.16.08;	author j;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.17.04.16.04;	author j;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.17.04.15.23;	author j;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.17.04.15.12;	author j;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.17.04.14.57;	author j;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.17.04.14.52;	author j;	state Exp;
branches;
next	1.56;

1.56
date	2013.03.17.04.13.27;	author j;	state Exp;
branches;
next	1.55;

1.55
date	2013.03.17.04.12.35;	author j;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.17.04.12.07;	author j;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.17.04.11.25;	author j;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.17.04.11.21;	author j;	state Exp;
branches;
next	1.51;

1.51
date	2013.03.17.04.11.17;	author j;	state Exp;
branches;
next	1.50;

1.50
date	2013.03.17.04.08.29;	author j;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.17.04.07.41;	author j;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.17.04.06.56;	author j;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.17.04.04.56;	author j;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.17.04.04.31;	author j;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.17.04.04.11;	author j;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.17.04.04.08;	author j;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.17.04.03.24;	author j;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.17.04.03.12;	author j;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.17.04.02.56;	author j;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.17.04.02.11;	author j;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.17.04.01.53;	author j;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.17.04.01.18;	author j;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.17.04.00.51;	author j;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.17.04.00.35;	author j;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.17.03.59.18;	author j;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.17.03.58.53;	author j;	state Exp;
branches;
next	1.33;

1.33
date	2013.03.17.03.58.29;	author j;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.17.03.57.44;	author j;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.17.03.56.46;	author j;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.17.03.55.43;	author j;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.17.03.55.21;	author j;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.17.03.48.41;	author j;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.17.03.48.28;	author j;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.17.03.46.45;	author j;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.17.03.45.34;	author j;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.17.03.41.32;	author j;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.17.03.41.05;	author j;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.17.03.40.53;	author j;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.17.03.38.55;	author j;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.17.03.38.48;	author j;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.17.03.38.16;	author j;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.17.03.37.43;	author j;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.17.03.36.34;	author j;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.17.03.32.45;	author j;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.17.03.23.11;	author j;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.17.01.31.48;	author j;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.17.01.31.31;	author j;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.17.01.30.55;	author j;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.17.01.30.50;	author j;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.17.01.29.39;	author j;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.17.01.29.34;	author j;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.17.01.29.31;	author j;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.17.01.28.25;	author j;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.17.01.27.51;	author j;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.17.01.27.05;	author j;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.17.01.25.45;	author j;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.17.01.25.34;	author j;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.17.01.25.04;	author j;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.17.01.05.28;	author j;	state Exp;
branches;
next	;


desc
@vim
@


1.130
log
@vim
@
text
@/**
    File: main.cpp
    Purpose: Blicket detector for Sifteo Cubes 

    @@author Jay B. Martin
    @@version 0.1 16 Mar 2013
*/


#include <sifteo.h>
#include "assets.gen.h"
using namespace Sifteo;

// Number of cubes to deploy (N blickets + 1 blicket detector)
static const unsigned gNumCubes = 5;
Random gRandom;

// METADATA
static Metadata M = Metadata()
    .title("Blicket Tutorial")
    .package("blickets", "0.1")
    .icon(Icon)
    .cubeRange(gNumCubes);


AssetSlot gMainSlot = AssetSlot::allocate()
    .bootstrap(BootstrapAssets);

// GLOBALS

static VideoBuffer vbuf[CUBE_ALLOCATION]; // one video-buffer per cube
static CubeSet newCubes; // new cubes as a result of paint()
static CubeSet lostCubes; // lost cubes as a result of paint()
static CubeSet reconnectedCubes; // reconnected (lost->new) cubes as a result of paint()
static CubeSet dirtyCubes; // dirty cubes as a result of paint()
static CubeSet activeCubes; // cubes showing the active scene

static AssetLoader loader; // global asset loader (each cube will have symmetric assets)
static AssetConfiguration<1> config; // global asset configuration (will just hold the bootstrap group)

// Experiment Globals
static CubeSet blicketCubes;
static CubeSet nonBlicketCubes;

static CubeID blicketDetector = 0;
static CubeID blicket1 = 1;
static CubeID blicket2 = 3;
static CubeID nonBlicket1 = 2;
static CubeID nonBlicket2 = 4;

// Set of 7 experimental conditions (see Gopnik & Sobel (2000))
AssetImage conditions[] = {Set1IdenticalObjects, Set2SameColorDifferentShape,
                           Set3SameShapeDifferentColors, Set4DifferentColorsAndShapes,
                           Set5SameShapeConflictsOnColor, Set6SameColorConflictsOnShape,
                           Set7ConflictsOnShapeAndColor};

class Conditions {
    int condition;
    public:
        void set_condition(int);
        AssetImage get_condition();
        int get_condition_number();
        void next_condition();
        Conditions();
};

void Conditions::set_condition(int condition_) { condition = condition_; };
AssetImage Conditions::get_condition() { return conditions[condition]; };
int Conditions::get_condition_number() { return condition; };
// TODO(Jay): Make condtions after 0 randomly selected.
void Conditions::next_condition() { condition = (condition + 1) % 7; };
Conditions::Conditions(){ condition = 0; }

// Initialize conditions
Conditions cond;

// FUNCTIONS

static void playSfx(const AssetAudio& sfx) {
    static int i=0;
    AudioChannel(i).play(sfx);
    i = 1 - i;
}

static void stopSfx() {
    static int i=0;
    AudioChannel(i).stop();
    i = 1 - i;
}

static Int2 getRestPosition(Side s) {
    // Look up the top-left pixel of the bar for the given side.
    // We use a switch so that the compiler can optimize this
    // however if feels is best.
    switch(s) {
      case TOP: return vec(64 - Bars[0].pixelWidth()/2, 0);
      case LEFT: return vec(0, 64 - Bars[1].pixelHeight()/2);
      case BOTTOM: return vec(64 - Bars[2].pixelWidth()/2, 128 - Bars[2].pixelHeight());
      case RIGHT: return vec(128 - Bars[3].pixelWidth(), 64 - Bars[3].pixelHeight()/2);
      default: return vec(0,0);
    }
}

static int barSpriteCount(CubeID cid) {
    // How many bars are showing on this cube?
    ASSERT(activeCubes.test(cid));
    int result = 0;
    for(int i=0; i < 4; ++i) {
        if (!vbuf[cid].sprites[i].isHidden()) {
            result++;
        }
    }
    return result;
}

static bool showSideBar(CubeID cid, Side s) {
    // If cid is not showing a bar on side s, show it and check if the
    // blicket detector shold go off.
    ASSERT(activeCubes.test(cid));
    if (vbuf[cid].sprites[s].isHidden()) {
        vbuf[cid].sprites[s].setImage(Bars[s]);
        vbuf[cid].sprites[s].move(getRestPosition(s));
        if (barSpriteCount(cid) == 1 && cid == 0) {
            vbuf[cid].bg0.image(vec(0,0), Backgrounds, 1);
        }
        else {
            vbuf[cid].bg0.image(vec(0,0), cond.get_condition(), cid - 1);
        }
        return true;
    } else {
        return false;
    }
}

static bool hideSideBar(CubeID cid, Side s) {
    // If cid is showing a bar on side s, hide it and check if the
    // blicket detector should turn off.
    ASSERT(activeCubes.test(cid));
    if (!vbuf[cid].sprites[s].isHidden()) {
        vbuf[cid].sprites[s].hide();
        if (barSpriteCount(cid) == 0 && cid == 0) {
            vbuf[cid].bg0.image(vec(0,0), Backgrounds, 0);
        }
        else {
            vbuf[cid].bg0.image(vec(0,0), cond.get_condition(), cid - 1);
        }
        return true;
    } else {
        return false;
    }
}

static void activateCube(CubeID cid) {
    // Mark cube as active and render its canvas
    //
    activeCubes.mark(cid);
    vbuf[cid].initMode(BG0_SPR_BG1);
    if (cid == 0) {
        vbuf[cid].bg0.image(vec(0,0), Backgrounds, 0);
    } else {
        vbuf[cid].bg0.image(vec(0,0), cond.get_condition(), cid - 1);
    }
    auto neighbors = vbuf[cid].physicalNeighbors();
    for(int side=0; side<4; ++side) {
        if (neighbors.hasNeighborAt(Side(side))) {
            showSideBar(cid, Side(side));
        } else {
            hideSideBar(cid, Side(side));
        }
    }
}

static void paintWrapper() {
    // Clear the palette
    newCubes.clear();
    lostCubes.clear();
    reconnectedCubes.clear();
    dirtyCubes.clear();

    // Fire events
    System::paint();

    // Dynamically load assets just-in-time
    if (!(newCubes | reconnectedCubes).empty()) {
        AudioTracker::pause();
        playSfx(SfxSong);
        loader.start(config);
        while(!loader.isComplete()) {
            for(CubeID cid : (newCubes | reconnectedCubes)) {
                vbuf[cid].bg0rom.hBargraph(
                    vec(0, 4), loader.cubeProgress(cid, 128), BG0ROMDrawable::ORANGE, 8
                );
            }
            // Fire events while we wait
            System::paint();
        }
        loader.finish();
        AudioTracker::resume();
    }

    // Repaint cubes
    for(CubeID cid : dirtyCubes) {
        activateCube(cid);
    }

    // Also, handle lost cubes, if you so desire :)
}

static void onCubeConnect(void* ctxt, unsigned cid) {
    // This cube is either new or reconnected
    if (lostCubes.test(cid)) {
        // This is a reconnected cube since it was already lost this paint()
        lostCubes.clear(cid);
        reconnectedCubes.mark(cid);
    } else {
        // This is a brand-spanking new cube
        newCubes.mark(cid);
    }
    // Begin showing some loading art (have to use BG0ROM since we don't have assets)
    dirtyCubes.mark(cid);
    auto& g = vbuf[cid];
    g.attach(cid);
    g.initMode(BG0_ROM);
    g.bg0rom.fill(vec(0, 0), vec(16, 16), BG0ROMDrawable::SOLID_BG);
    g.bg0rom.text(vec(1, 1), "Hold on!", BG0ROMDrawable::BLUE);
    g.bg0rom.text(vec(1, 14), "Adding Cube...", BG0ROMDrawable::BLUE);
}

static void onCubeDisconnect(void* ctxt, unsigned cid) {
    // Mark as lost and clear from other cube sets
    lostCubes.mark(cid);
    newCubes.clear(cid);
    reconnectedCubes.clear(cid);
    dirtyCubes.clear(cid);
    activeCubes.clear(cid);
}

static void onCubeRefresh(void* ctxt, unsigned cid) {
    // Mark this cube for a future repaint
    dirtyCubes.mark(cid);
}

static bool isActive(NeighborID nid) {
    // Does this nid indicate an active cube?
    return nid.isCube() && activeCubes.test(nid);
}

static void onNeighborAdd(void* ctxt, unsigned cube0, unsigned side0, unsigned cube1, unsigned side1) {
    // Update art on active cubes (not loading cubes or base)
    bool sfx = false;
    if (isActive(cube0) && cube0 == blicketDetector && blicketCubes.test(cube1)) {
        sfx |= showSideBar(cube1, Side(side1));
        sfx |= showSideBar(cube0, Side(side0));
    }
    if (isActive(cube1) && cube1 == blicketDetector && blicketCubes.test(cube0)) {
        sfx |= showSideBar(cube0, Side(side0));
        sfx |= showSideBar(cube1, Side(side1));
    }
    if (sfx) { playSfx(SfxSong); }
}

static void onNeighborRemove(void* ctxt, unsigned cube0, unsigned side0, unsigned cube1, unsigned side1) {
    // Update art on active cubes (not loading cubes or base)
    bool sfx = false;
    if (isActive(cube0) && cube0 == blicketDetector && blicketCubes.test(cube1)) {
        sfx |= hideSideBar(cube1, Side(side1));
        sfx |= hideSideBar(cube0, Side(side0));
    }
    if (isActive(cube1) && cube1 == blicketDetector && blicketCubes.test(cube0)) {
       sfx |= hideSideBar(cube1, Side(side1));
       sfx |= hideSideBar(cube0, Side(side0));
    }
    if (sfx) { playSfx(SfxDetach); }
    if (sfx) { stopSfx(); }
}

// Candidate function for interventions
static void onCubeTouch(void* ctxt, unsigned cid) {
    cond.next_condition();
    LOG("Condition %i\n", cond.get_condition_number());
    for(CubeID cid : CubeSet::connected()) {
        vbuf[cid].attach(cid);
        activateCube(cid);
    }
}

// When pressed, move to the next condition
void onTouch(void* ctxt, unsigned id) {
    CubeID cube(id);
    // On touchout (similar to mouseout)
    if (cube.isTouching() == 0) {
        cond.next_condition();
            LOG("Condition %i\n", cond.get_condition_number());
        for(CubeID cid : CubeSet::connected()) {
            vbuf[cid].attach(cid);
            activateCube(cid);
        }
    }
}

void main() {
    blicketCubes.mark(blicket1);
    blicketCubes.mark(blicket2);
    nonBlicketCubes.mark(nonBlicket1);
    nonBlicketCubes.mark(nonBlicket2);

    // Initialize asset configuration and loader
    config.append(gMainSlot, BootstrapAssets);
    loader.init();

    // Subscribe to events (See pubsub design pattern)
    Events::cubeConnect.set(onCubeConnect);
    Events::cubeDisconnect.set(onCubeDisconnect);
    Events::cubeRefresh.set(onCubeRefresh);
    Events::neighborAdd.set(onNeighborAdd);
    Events::neighborRemove.set(onNeighborRemove);
    // Events::cubeTouch.set(onCubeTouch);
    Events::cubeTouch.set(onTouch);

    // Initialize cubes
    for(CubeID cid : CubeSet::connected()) {
        vbuf[cid].attach(cid);
        activateCube(cid);
    }

    // Run loop
    for(;;) {
        paintWrapper();
    }
}
@


1.129
log
@vim
@
text
@d287 1
@


1.128
log
@vim
@
text
@d289 1
a289 1
    // TouchOut (similar to mouseout)
@


1.127
log
@vim
@
text
@d289 1
@


1.126
log
@vim
@
text
@a288 1
    LOG("Touch event on cube #%d, state=%d\n", id, cube.isTouching());
@


1.125
log
@vim
@
text
@d71 1
a71 1
void Conditions::next_condition() { condition = (condition + 1); };
@


1.124
log
@vim
@
text
@d71 1
a71 1
void Conditions::next_condition() { condition = (condition + 1) % 2; };
@


1.123
log
@vim
@
text
@d290 1
a290 1
    if (cube.isTouching == 0) {
@


1.122
log
@vim
@
text
@d291 2
a292 2
    cond.next_condition();
        LOG("Condition %i\n", cond.get_condition_number());
@


1.121
log
@vim
@
text
@d290 8
a297 3
    // String<32> str;
//    str << "touch: " << cube.isTouching() << " (" << counters[cube].touch << ")\n";
    // vid[cube].bg0rom.text(vec(1,9), str);
@


1.120
log
@vim
@
text
@d287 1
a287 1
void onTouch(unsigned id) {
@


1.119
log
@vim
@
text
@d290 1
a290 1
    String<32> str;
d292 1
a292 1
    vid[cube].bg0rom.text(vec(1,9), str);
@


1.118
log
@vim
@
text
@d291 1
a291 2
    str << "touch: " << cube.isTouching() <<
        " (" << counters[cube].touch << ")\n";
@


1.117
log
@vim
@
text
@a288 1
    counters[id].touch++;
a289 1

@


1.116
log
@vim
@
text
@d314 1
a314 1
    Events::cubeTouch.set(onCubeTouch);
@


1.115
log
@vim
@
text
@d315 1
a315 1
    Events::cubeTouch.set(onTouch, this);
@


1.114
log
@vim
@
text
@d287 11
d315 1
@


1.113
log
@vim
@
text
@d71 1
a71 1
void Conditions::next_condition() { condition = condition + 1; };
@


1.112
log
@vim
@
text
@a284 1
    System::vsleep(5000);
@


1.111
log
@vim
@
text
@d285 1
a285 1
    vsleep(5000);
@


1.110
log
@vim
@
text
@d285 1
a285 1
    usleep(5000);
@


1.109
log
@vim
@
text
@a11 1
#include <unistd.h>
@


1.108
log
@vim
@
text
@d12 1
@


1.107
log
@vim
@
text
@d285 1
a285 1
    usleep(500);
@


1.106
log
@vim
@
text
@d285 1
a285 1
    Sleep(500);
@


1.105
log
@vim
@
text
@d285 1
@


1.104
log
@vim
@
text
@a278 5
    LOG("Cube Touched %i\n", cid);
    CubeID cube(cid);
    if(cube.isTouching()) {
        LOG("Touched cube %i\n", cid);
    }
@


1.103
log
@vim
@
text
@d285 1
a285 1
        LOG("Condition %i\n", cond.get_condition_number());
@


1.102
log
@vim
@
text
@d308 1
a308 1
  //   Events::cubeTouch.set(onCubeTouch);
@


1.101
log
@vim
@
text
@a302 1
    Events::cubeTouch.set(TouchHandler);
@


1.100
log
@vim
@
text
@a276 11
class CubeWrapper {
    public:
        virtual void onTouch() {};
};

CubeWrapper cubes[gNumCubes];

void TouchHandler(void*, unsigned cube) {
    cubes[cube].onTouch();
}

@


1.99
log
@vim
@
text
@d320 1
a320 1
    Events::cubeTouch.set(onCubeTouch);
@


1.98
log
@vim
@
text
@a314 1
    while(1) System::paint();
@


1.97
log
@vim
@
text
@a287 5
void main() {
    Events::cubeTouch.set(TouchHandler);
    while(1) System::paint();
}

d314 2
@


1.96
log
@vim
@
text
@a323 1
    Events::TouchHandler.set(onCubeTouch);
@


1.95
log
@vim
@
text
@d325 1
a325 1
//    Events::cubeTouch.set(onCubeTouch);
@


1.94
log
@vim
@
text
@d324 1
a324 2
    Events::OnTouch.set(onCubeTouch);
    OnTouch(0);
@


1.93
log
@vim
@
text
@d277 14
a290 15
CubeSet oldTouching;
void OnTouch(unsigned cube) {
    if(CubeID(cube).isTouching() && !oldTouching.test(cube)) {
        //touch on
        oldTouching.mark(cube);
    } else if(!CubeID(cube).isTouching() && oldTouching.test(cube)) {
        //touch off
        cond.next_condition();
        LOG("Condition %i\n", cond.get_condition_number());
        for(CubeID cid : CubeSet::connected()) {
            vbuf[cid].attach(cid);
            activateCube(cid);
        }
        oldTouching.clear(cube);
    }
@


1.92
log
@vim
@
text
@d285 1
a285 1
            LOG("Condition %i\n", cond.get_condition_number());
d290 1
d325 1
@


1.91
log
@vim
@
text
@a284 1
        cond.next_condition();
@


1.90
log
@vim
@
text
@d285 7
a291 6
      cond.next_condition();
          LOG("Condition %i\n", cond.get_condition_number());
      for(CubeID cid : CubeSet::connected()) {
          vbuf[cid].attach(cid);
          activateCube(cid);
      }
@


1.89
log
@vim
@
text
@d285 6
a290 1
    }
@


1.88
log
@vim
@
text
@d278 1
a278 1
void OnTouch(void*, unsigned cube) {
@


1.87
log
@vim
@
text
@d319 1
a319 1
    OnTouch.(0);
@


1.86
log
@vim
@
text
@d319 1
a319 1
    OnTouch.set(onCubeTouch);
@


1.85
log
@vim
@
text
@d319 1
a319 1
    Events::OnTouch.set(onCubeTouch);
@


1.84
log
@vim
@
text
@a284 6
        LOG("Condition %i\n", cond.get_condition_number());
        for(CubeID cid : CubeSet::connected()) {
            vbuf[cid].attach(cid);
            activateCube(cid);
        }
        oldTouching.clear(cube);
d319 1
@


1.83
log
@vim
@
text
@d284 6
@


1.82
log
@vim
@
text
@a319 1
    Events::oldTouching(onCubeTouch);
@


1.81
log
@vim
@
text
@d319 2
a320 1
    Events::cubeTouch.set(onCubeTouch);
@


1.80
log
@vim
@
text
@d277 11
@


1.79
log
@vim
@
text
@d62 1
d69 1
@


1.78
log
@vim
@
text
@d58 6
a63 6
  int condition;
  public:
    void set_condition(int);
    AssetImage get_condition();
    void next_condition();
    Conditions();
d283 1
@


1.77
log
@vim
@
text
@d275 1
a275 1
// Candidate function for interventios
a282 9
}

static void onNewCondition(void* ctxt, unsigned cid) {
    LOG("Cube Touched %i\n", cid);
    CubeID cube(cid);
    if(cube.isTouching()) {
        LOG("Touched cube %i\n", cid);
    }
    cond.next_condition();
@


1.76
log
@vim
@
text
@a282 1
    Paint();
d292 4
@


1.75
log
@vim
@
text
@d283 1
@


1.74
log
@vim
@
text
@a282 1
    System::paint();
@


1.73
log
@vim
@
text
@d283 1
a283 1
    paint();
@


1.72
log
@vim
@
text
@d283 1
a283 1
    Events::cubeRefresh;
@


1.71
log
@vim
@
text
@d283 1
a283 1
    Events::cubeRefresh();
@


1.70
log
@vim
@
text
@d283 1
d286 1
a286 1
static void newCondition(void* ctxt, unsigned cid) {
a311 1
    Events::cubeRefresh.set(onNewCondition);
@


1.69
log
@vim
@
text
@d311 1
a311 1
    Events::newCondition.set(onNewCondition);
@


1.68
log
@vim
@
text
@d285 9
d311 1
@


1.67
log
@vim
@
text
@d69 1
a69 1
int Conditions::next_condition() { condition = condition + 1; };
@


1.66
log
@vim
@
text
@d62 1
@


1.65
log
@vim
@
text
@d68 1
a68 1
int Conditions::next_condition() { return condition + 1; };
@


1.64
log
@vim
@
text
@d281 1
a281 1
    cond.set_condition(cond.get_condition() + 1);
@


1.63
log
@vim
@
text
@a284 2


@


1.62
log
@vim
@
text
@d71 1
@


1.61
log
@vim
@
text
@a72 2
// TODO(Jay): Select condition by tilting or clicking the blicket detector.
//
@


1.60
log
@vim
@
text
@d67 2
a68 1
int Conditions::get_condition_number() { return condition; };
@


1.59
log
@vim
@
text
@d67 1
a67 1
int Conditions::get_condition_number() { return conditions[condition]; };
@


1.58
log
@vim
@
text
@d67 1
@


1.57
log
@vim
@
text
@d67 1
a67 1
Conditions::Conditions(){ condition; }
@


1.56
log
@vim
@
text
@d67 1
a67 1
Conditions::Conditions(){ condition = 0; }
@


1.55
log
@vim
@
text
@d280 1
@


1.54
log
@vim
@
text
@d62 1
a62 1
    void Conditions();
@


1.53
log
@vim
@
text
@d62 1
d67 1
a67 1
Conditions::Conditions(int a){ condition = 0; }
@


1.52
log
@vim
@
text
@d66 1
a66 3
Conditions::Conditions(int a){
  condition = 0;
}
@


1.51
log
@vim
@
text
@d67 1
a67 1
  condition = a;
@


1.50
log
@vim
@
text
@d66 3
a70 1
cond.set_condition(0);
@


1.49
log
@vim
@
text
@d67 3
d282 1
a282 2
    Conditions cond;
    cond.set_condition(0);
@


1.48
log
@vim
@
text
@d119 1
a119 1
            vbuf[cid].bg0.image(vec(0,0), condition, cid - 1);
d137 1
a137 1
            vbuf[cid].bg0.image(vec(0,0), condition, cid - 1);
d153 1
a153 1
        vbuf[cid].bg0.image(vec(0,0), condition, cid - 1);
@


1.47
log
@vim
@
text
@a280 1
    AssetImage condition = cond.get_condition();
@


1.46
log
@vim
@
text
@d68 1
a68 4
Conditions cond;
cond.set_condition(0);
AssetImage condition = cond.get_condition();

d279 3
@


1.45
log
@vim
@
text
@d68 1
a68 1
Conditions cond; 
@


1.44
log
@vim
@
text
@d70 1
a70 1
AssetImage condition = cond.get_condition(0);
@


1.43
log
@vim
@
text
@d69 2
a70 1
AssetImage condition = cond.set_condition(0);
@


1.42
log
@vim
@
text
@d69 1
a69 1
AssetImage condition = cond.set(0);
@


1.41
log
@vim
@
text
@d69 1
a69 1
condition = cond.set(0);
@


1.40
log
@vim
@
text
@d68 1
a68 1
Condition cond; 
@


1.39
log
@vim
@
text
@d68 2
a69 1

d281 1
a281 2
    Condition cond; 
    condition = cond.set(0);
@


1.38
log
@vim
@
text
@a111 1
    ImageAsset condition = cond.get_condition();
a130 1
    condition = cond.get_condition();
a148 1
    condition = cond.get_condition();
@


1.37
log
@vim
@
text
@d112 1
a112 1
    condition = cond.get_condition();
@


1.36
log
@vim
@
text
@d150 2
@


1.35
log
@vim
@
text
@d112 1
d132 1
@


1.34
log
@vim
@
text
@d61 1
a61 1
    int get_condition();
@


1.33
log
@vim
@
text
@d60 1
a60 1
    void set_condition(int) { condition = int };
@


1.32
log
@vim
@
text
@d62 1
a62 1
}
@


1.31
log
@vim
@
text
@a67 1
AssetImage condition = conditions[5];
d279 2
@


1.30
log
@vim
@
text
@d51 6
d65 1
a65 8
int Conditions::get_condition() { return condition; };


// Set of 7 experimental conditions (see Gopnik & Sobel (2000))
AssetImage conditions[] = {Set1IdenticalObjects, Set2SameColorDifferentShape,
                           Set3SameShapeDifferentColors, Set4DifferentColorsAndShapes,
                           Set5SameShapeConflictsOnColor, Set6SameColorConflictsOnShape,
                           Set7ConflictsOnShapeAndColor};
@


1.29
log
@vim
@
text
@d59 1
a59 1
int Conditions::get_condition();
@


1.28
log
@vim
@
text
@d51 11
@


1.27
log
@vim
@
text
@d72 1
@


1.26
log
@vim
@
text
@d70 2
a71 3
    for (int i=0; i < 0; i++) {
      AudioChannel(i).stop();
    }
@


1.25
log
@vim
@
text
@d241 1
d245 1
a245 1
void onNeighborRemove(void* ctxt, unsigned cube0, unsigned side0, unsigned cube1, unsigned side1) {
@


1.24
log
@vim
@
text
@d244 1
a244 1
static void onNeighborRemove(void* ctxt, unsigned cube0, unsigned side0, unsigned cube1, unsigned side1) {
@


1.23
log
@vim
@
text
@d249 1
a249 1
        sfx |= hideSideBar(cube0, Side(side0))
d253 1
a253 1
       sfx |= hideSideBar(cube0, Side(side0))
@


1.22
log
@vim
@
text
@d58 1
a58 1
AssetImage condition = conditions[3];
@


1.21
log
@vim
@
text
@a11 1
#include <algorithm>
@


1.20
log
@vim
@
text
@a241 1
    
@


1.19
log
@vim
@
text
@d240 1
a240 1
        sfx |= showSideBar(cube0, Side(side0));  
d242 1
a242 1
    }
d250 2
a251 1
        sfx |= hideSideBar(cube0, Side(side0));
d255 1
a255 1
       sfx |= showSideBar(cube0, Side(side0))
@


1.18
log
@vim
@
text
@d236 2
a237 1
        sfx |= showSideBar(cube1, Side(side1));  sfx |= showSideBar(cube0, Side(side0));
d240 2
a241 1
        sfx |= showSideBar(cube0, Side(side0));  sfx |= showSideBar(cube1, Side(side1));
d254 1
@


1.17
log
@vim
@
text
@d247 6
a252 2
    if (isActive(cube0)) { sfx |= hideSideBar(cube0, Side(side0)); }
    if (isActive(cube1)) { sfx |= hideSideBar(cube1, Side(side1)); }
@


1.16
log
@vim
@
text
@d208 3
a210 3
    g.bg0rom.fill(vec(0,0), vec(16,16), BG0ROMDrawable::SOLID_BG);
    g.bg0rom.text(vec(1,1), "Hold on!", BG0ROMDrawable::BLUE);
    g.bg0rom.text(vec(1,14), "Adding Cube...", BG0ROMDrawable::BLUE);
d235 6
a240 2
    if (isActive(cube0) && cube0 == blicketDetector && blicketCubes.test(cube1)) { sfx |= showSideBar(cube1, Side(side1));  sfx |= showSideBar(cube0, Side(side0));}
    if (isActive(cube1) && cube1 == blicketDetector && blicketCubes.test(cube0)) { sfx |= showSideBar(cube0, Side(side0));  sfx |= showSideBar(cube1, Side(side1));}
@


1.15
log
@vim
@
text
@d12 1
@


1.14
log
@vim
@
text
@d47 2
a48 2
static CubeID blicket2 = 2;
static CubeID nonBlicket1 = 3;
@


1.13
log
@vim
@
text
@d263 1
a263 1
    // initialize asset configuration and loader
d275 1
d281 1
a281 1
    // run loop
@


1.12
log
@vim
@
text
@d267 1
a267 1
    // subscribe to events
a270 1

@


1.11
log
@vim
@
text
@d248 1
a248 1
// Candidate function for intervention
@


1.10
log
@vim
@
text
@d138 1
a138 1
    // mark cube as active and render its canvas
d157 1
a157 1
    // clear the palette
d163 1
a163 1
    // fire events
d166 1
a166 1
    // dynamically load assets just-in-time
a168 1
        // playSfx(SfxConnect);
d177 1
a177 1
            // fire events while we wait
d184 1
a184 1
    // repaint cubes
d189 1
a189 1
    // also, handle lost cubes, if you so desire :)
d193 1
a193 1
    // this cube is either new or reconnected
d195 1
a195 1
        // this is a reconnected cube since it was already lost this paint()
d199 1
a199 1
        // this is a brand-spanking new cube
d202 1
a202 1
    // begin showing some loading art (have to use BG0ROM since we don't have assets)
d213 1
a213 1
    // mark as lost and clear from other cube sets
d222 1
a222 1
    // mark this cube for a future repaint
d232 1
a232 1
    // update art on active cubes (not loading cubes or base)
a235 3
    // if (isActive(cube1) && causeCubes.test(cube0) && effectCubes.test(cube1)) { sfx |= showSideBar(cube0, Side(side0)); }
    // if (isActive(cube1)) { sfx |= showSideBar(cube1, Side(side1)); }
    // if (sfx) { playSfx(SfxAttach); }
d240 1
a240 1
    // update art on active cubes (not loading cubes or base)
d248 1
a248 1
// Candidate for intervention
@


1.9
log
@vim
@
text
@d89 1
a89 1
    // how many bars are showing on this cube?
d101 1
a101 1
    // if cid is not showing a bar on side s, show it and check if the
@


1.8
log
@vim
@
text
@d120 1
a120 1
    // if cid is showing a bar on side s, hide it and check if the
@


1.7
log
@vim
@
text
@d102 1
a102 1
    // smiley should wake up
d121 1
a121 1
    // smiley should go to sleep
@


1.6
log
@vim
@
text
@d51 1
d60 1
@


1.5
log
@vim
@
text
@d55 2
@


1.4
log
@vim
@
text
@a36 2
static CubeSet blicketCubes;
static CubeSet nonBlicketCubes;
d41 4
@


1.3
log
@vim
@
text
@a13 2
// METADATA

d18 1
@


1.2
log
@vim
@
text
@d16 1
@


1.1
log
@vim
@
text
@d1 8
a8 3
/*
 * Sifteo SDK Example.
 */
@
