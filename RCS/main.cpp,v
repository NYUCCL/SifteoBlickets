head	1.14;
access;
symbols;
locks
	j:1.14; strict;
comment	@// @;
expand	@o@;


1.14
date	2013.03.17.01.31.48;	author j;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.17.01.31.31;	author j;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.17.01.30.55;	author j;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.17.01.30.50;	author j;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.17.01.29.39;	author j;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.17.01.29.34;	author j;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.17.01.29.31;	author j;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.17.01.28.25;	author j;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.17.01.27.51;	author j;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.17.01.27.05;	author j;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.17.01.25.45;	author j;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.17.01.25.34;	author j;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.17.01.25.04;	author j;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.17.01.05.28;	author j;	state Exp;
branches;
next	;


desc
@vim
@


1.14
log
@vim
@
text
@/**
    File: main.cpp
    Purpose: Blicket detector for Sifteo Cubes 

    @@author Jay B. Martin
    @@version 0.1 16 Mar 2013
*/


#include <sifteo.h>
#include "assets.gen.h"
using namespace Sifteo;

// Number of cubes to deploy (N blickets + 1 blicket detector)
static const unsigned gNumCubes = 5;
Random gRandom;

// METADATA
static Metadata M = Metadata()
    .title("Blicket Tutorial")
    .package("blickets", "0.1")
    .icon(Icon)
    .cubeRange(gNumCubes);


AssetSlot gMainSlot = AssetSlot::allocate()
    .bootstrap(BootstrapAssets);

// GLOBALS

static VideoBuffer vbuf[CUBE_ALLOCATION]; // one video-buffer per cube
static CubeSet newCubes; // new cubes as a result of paint()
static CubeSet lostCubes; // lost cubes as a result of paint()
static CubeSet reconnectedCubes; // reconnected (lost->new) cubes as a result of paint()
static CubeSet dirtyCubes; // dirty cubes as a result of paint()
static CubeSet activeCubes; // cubes showing the active scene

static AssetLoader loader; // global asset loader (each cube will have symmetric assets)
static AssetConfiguration<1> config; // global asset configuration (will just hold the bootstrap group)

// Experiment Globals
static CubeSet blicketCubes;
static CubeSet nonBlicketCubes;

static CubeID blicketDetector = 0;
static CubeID blicket1 = 1;
static CubeID blicket2 = 2;
static CubeID nonBlicket1 = 3;
static CubeID nonBlicket2 = 4;

// Set of 7 experimental conditions (see Gopnik & Sobel (2000))
AssetImage conditions[] = {Set1IdenticalObjects, Set2SameColorDifferentShape,
                           Set3SameShapeDifferentColors, Set4DifferentColorsAndShapes,
                           Set5SameShapeConflictsOnColor, Set6SameColorConflictsOnShape,
                           Set7ConflictsOnShapeAndColor};

// TODO(Jay): Select condition by tilting or clicking the blicket detector.
AssetImage condition = conditions[3];


// FUNCTIONS

static void playSfx(const AssetAudio& sfx) {
    static int i=0;
    AudioChannel(i).play(sfx);
    i = 1 - i;
}

static void stopSfx() {
    for (int i=0; i < 0; i++) {
      AudioChannel(i).stop();
    }
}

static Int2 getRestPosition(Side s) {
    // Look up the top-left pixel of the bar for the given side.
    // We use a switch so that the compiler can optimize this
    // however if feels is best.
    switch(s) {
      case TOP: return vec(64 - Bars[0].pixelWidth()/2, 0);
      case LEFT: return vec(0, 64 - Bars[1].pixelHeight()/2);
      case BOTTOM: return vec(64 - Bars[2].pixelWidth()/2, 128 - Bars[2].pixelHeight());
      case RIGHT: return vec(128 - Bars[3].pixelWidth(), 64 - Bars[3].pixelHeight()/2);
      default: return vec(0,0);
    }
}

static int barSpriteCount(CubeID cid) {
    // How many bars are showing on this cube?
    ASSERT(activeCubes.test(cid));
    int result = 0;
    for(int i=0; i < 4; ++i) {
        if (!vbuf[cid].sprites[i].isHidden()) {
            result++;
        }
    }
    return result;
}

static bool showSideBar(CubeID cid, Side s) {
    // If cid is not showing a bar on side s, show it and check if the
    // blicket detector shold go off.
    ASSERT(activeCubes.test(cid));
    if (vbuf[cid].sprites[s].isHidden()) {
        vbuf[cid].sprites[s].setImage(Bars[s]);
        vbuf[cid].sprites[s].move(getRestPosition(s));
        if (barSpriteCount(cid) == 1 && cid == 0) {
            vbuf[cid].bg0.image(vec(0,0), Backgrounds, 1);
        }
        else {
            vbuf[cid].bg0.image(vec(0,0), condition, cid - 1);
        }
        return true;
    } else {
        return false;
    }
}

static bool hideSideBar(CubeID cid, Side s) {
    // If cid is showing a bar on side s, hide it and check if the
    // blicket detector should turn off.
    ASSERT(activeCubes.test(cid));
    if (!vbuf[cid].sprites[s].isHidden()) {
        vbuf[cid].sprites[s].hide();
        if (barSpriteCount(cid) == 0 && cid == 0) {
            vbuf[cid].bg0.image(vec(0,0), Backgrounds, 0);
        }
        else {
            vbuf[cid].bg0.image(vec(0,0), condition, cid - 1);
        }
        return true;
    } else {
        return false;
    }
}

static void activateCube(CubeID cid) {
    // Mark cube as active and render its canvas
    activeCubes.mark(cid);
    vbuf[cid].initMode(BG0_SPR_BG1);
    if (cid == 0) {
        vbuf[cid].bg0.image(vec(0,0), Backgrounds, 0);
    } else {
        vbuf[cid].bg0.image(vec(0,0), condition, cid - 1);
    }
    auto neighbors = vbuf[cid].physicalNeighbors();
    for(int side=0; side<4; ++side) {
        if (neighbors.hasNeighborAt(Side(side))) {
            showSideBar(cid, Side(side));
        } else {
            hideSideBar(cid, Side(side));
        }
    }
}

static void paintWrapper() {
    // Clear the palette
    newCubes.clear();
    lostCubes.clear();
    reconnectedCubes.clear();
    dirtyCubes.clear();

    // Fire events
    System::paint();

    // Dynamically load assets just-in-time
    if (!(newCubes | reconnectedCubes).empty()) {
        AudioTracker::pause();
        playSfx(SfxSong);
        loader.start(config);
        while(!loader.isComplete()) {
            for(CubeID cid : (newCubes | reconnectedCubes)) {
                vbuf[cid].bg0rom.hBargraph(
                    vec(0, 4), loader.cubeProgress(cid, 128), BG0ROMDrawable::ORANGE, 8
                );
            }
            // Fire events while we wait
            System::paint();
        }
        loader.finish();
        AudioTracker::resume();
    }

    // Repaint cubes
    for(CubeID cid : dirtyCubes) {
        activateCube(cid);
    }

    // Also, handle lost cubes, if you so desire :)
}

static void onCubeConnect(void* ctxt, unsigned cid) {
    // This cube is either new or reconnected
    if (lostCubes.test(cid)) {
        // This is a reconnected cube since it was already lost this paint()
        lostCubes.clear(cid);
        reconnectedCubes.mark(cid);
    } else {
        // This is a brand-spanking new cube
        newCubes.mark(cid);
    }
    // Begin showing some loading art (have to use BG0ROM since we don't have assets)
    dirtyCubes.mark(cid);
    auto& g = vbuf[cid];
    g.attach(cid);
    g.initMode(BG0_ROM);
    g.bg0rom.fill(vec(0,0), vec(16,16), BG0ROMDrawable::SOLID_BG);
    g.bg0rom.text(vec(1,1), "Hold on!", BG0ROMDrawable::BLUE);
    g.bg0rom.text(vec(1,14), "Adding Cube...", BG0ROMDrawable::BLUE);
}

static void onCubeDisconnect(void* ctxt, unsigned cid) {
    // Mark as lost and clear from other cube sets
    lostCubes.mark(cid);
    newCubes.clear(cid);
    reconnectedCubes.clear(cid);
    dirtyCubes.clear(cid);
    activeCubes.clear(cid);
}

static void onCubeRefresh(void* ctxt, unsigned cid) {
    // Mark this cube for a future repaint
    dirtyCubes.mark(cid);
}

static bool isActive(NeighborID nid) {
    // Does this nid indicate an active cube?
    return nid.isCube() && activeCubes.test(nid);
}

static void onNeighborAdd(void* ctxt, unsigned cube0, unsigned side0, unsigned cube1, unsigned side1) {
    // Update art on active cubes (not loading cubes or base)
    bool sfx = false;
    if (isActive(cube0) && cube0 == blicketDetector && blicketCubes.test(cube1)) { sfx |= showSideBar(cube1, Side(side1));  sfx |= showSideBar(cube0, Side(side0));}
    if (isActive(cube1) && cube1 == blicketDetector && blicketCubes.test(cube0)) { sfx |= showSideBar(cube0, Side(side0));  sfx |= showSideBar(cube1, Side(side1));}
    if (sfx) { playSfx(SfxSong); }
}

static void onNeighborRemove(void* ctxt, unsigned cube0, unsigned side0, unsigned cube1, unsigned side1) {
    // Update art on active cubes (not loading cubes or base)
    bool sfx = false;
    if (isActive(cube0)) { sfx |= hideSideBar(cube0, Side(side0)); }
    if (isActive(cube1)) { sfx |= hideSideBar(cube1, Side(side1)); }
    if (sfx) { playSfx(SfxDetach); }
    if (sfx) { stopSfx(); }
}

// Candidate function for interventios
static void onCubeTouch(void* ctxt, unsigned cid) {
    LOG("Cube Touched %i\n", cid);
    CubeID cube(cid);
    if(cube.isTouching()) {
        LOG("Touched cube %i\n", cid);
    }
}

void main() {
    blicketCubes.mark(blicket1);
    blicketCubes.mark(blicket2);
    nonBlicketCubes.mark(nonBlicket1);
    nonBlicketCubes.mark(nonBlicket2);

    // Initialize asset configuration and loader
    config.append(gMainSlot, BootstrapAssets);
    loader.init();

    // Subscribe to events (See pubsub design pattern)
    Events::cubeConnect.set(onCubeConnect);
    Events::cubeDisconnect.set(onCubeDisconnect);
    Events::cubeRefresh.set(onCubeRefresh);
    Events::neighborAdd.set(onNeighborAdd);
    Events::neighborRemove.set(onNeighborRemove);
    Events::cubeTouch.set(onCubeTouch);

    // Initialize cubes
    for(CubeID cid : CubeSet::connected()) {
        vbuf[cid].attach(cid);
        activateCube(cid);
    }

    // Run loop
    for(;;) {
        paintWrapper();
    }
}
@


1.13
log
@vim
@
text
@d263 1
a263 1
    // initialize asset configuration and loader
d275 1
d281 1
a281 1
    // run loop
@


1.12
log
@vim
@
text
@d267 1
a267 1
    // subscribe to events
a270 1

@


1.11
log
@vim
@
text
@d248 1
a248 1
// Candidate function for intervention
@


1.10
log
@vim
@
text
@d138 1
a138 1
    // mark cube as active and render its canvas
d157 1
a157 1
    // clear the palette
d163 1
a163 1
    // fire events
d166 1
a166 1
    // dynamically load assets just-in-time
a168 1
        // playSfx(SfxConnect);
d177 1
a177 1
            // fire events while we wait
d184 1
a184 1
    // repaint cubes
d189 1
a189 1
    // also, handle lost cubes, if you so desire :)
d193 1
a193 1
    // this cube is either new or reconnected
d195 1
a195 1
        // this is a reconnected cube since it was already lost this paint()
d199 1
a199 1
        // this is a brand-spanking new cube
d202 1
a202 1
    // begin showing some loading art (have to use BG0ROM since we don't have assets)
d213 1
a213 1
    // mark as lost and clear from other cube sets
d222 1
a222 1
    // mark this cube for a future repaint
d232 1
a232 1
    // update art on active cubes (not loading cubes or base)
a235 3
    // if (isActive(cube1) && causeCubes.test(cube0) && effectCubes.test(cube1)) { sfx |= showSideBar(cube0, Side(side0)); }
    // if (isActive(cube1)) { sfx |= showSideBar(cube1, Side(side1)); }
    // if (sfx) { playSfx(SfxAttach); }
d240 1
a240 1
    // update art on active cubes (not loading cubes or base)
d248 1
a248 1
// Candidate for intervention
@


1.9
log
@vim
@
text
@d89 1
a89 1
    // how many bars are showing on this cube?
d101 1
a101 1
    // if cid is not showing a bar on side s, show it and check if the
@


1.8
log
@vim
@
text
@d120 1
a120 1
    // if cid is showing a bar on side s, hide it and check if the
@


1.7
log
@vim
@
text
@d102 1
a102 1
    // smiley should wake up
d121 1
a121 1
    // smiley should go to sleep
@


1.6
log
@vim
@
text
@d51 1
d60 1
@


1.5
log
@vim
@
text
@d55 2
@


1.4
log
@vim
@
text
@a36 2
static CubeSet blicketCubes;
static CubeSet nonBlicketCubes;
d41 4
@


1.3
log
@vim
@
text
@a13 2
// METADATA

d18 1
@


1.2
log
@vim
@
text
@d16 1
@


1.1
log
@vim
@
text
@d1 8
a8 3
/*
 * Sifteo SDK Example.
 */
@
